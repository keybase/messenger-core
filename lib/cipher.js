// Generated by IcedCoffeeScript 1.7.1-b
(function() {
  var AES, C, CTR, Cipher, HMAC, Key, WordArray, bufeq_secure, check_template, checkers, encode, hmac, iced, pack, prng, tsec, __iced_k, __iced_k_noop, _ref;

  iced = require('iced-coffee-script').iced;
  __iced_k = __iced_k_noop = function() {};

  tsec = require('triplesec');

  WordArray = tsec.WordArray, hmac = tsec.hmac, prng = tsec.prng, HMAC = tsec.HMAC;

  AES = tsec.ciphers.AES;

  CTR = tsec.modes.CTR;

  pack = require('purepack').pack;

  bufeq_secure = require('iced-utils').util.bufeq_secure;

  C = require('./const');

  _ref = require('keybase-bjson-core'), encode = _ref.encode, check_template = _ref.check_template, checkers = _ref.checkers;

  Key = (function() {
    Key.sizes = {
      HMAC: 32,
      AES: AES.keySize
    };

    Key.prototype.sizes = Key.sizes;

    function Key(_arg) {
      this.s = _arg.s, this.m = _arg.m;
    }

    Key.prototype.generate = function(cb) {
      var ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/messenger-core/src/cipher.iced",
            funcname: "Key.generate"
          });
          prng.generate(_this.sizes.HMAC, __iced_deferrals.defer({
            assign_fn: (function(__slot_1) {
              return function() {
                return __slot_1.m = arguments[0];
              };
            })(_this),
            lineno: 24
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/Users/max/src/keybase/messenger-core/src/cipher.iced",
              funcname: "Key.generate"
            });
            prng.generate(_this.sizes.AES, __iced_deferrals.defer({
              assign_fn: (function(__slot_1) {
                return function() {
                  return __slot_1.s = arguments[0];
                };
              })(_this),
              lineno: 25
            }));
            __iced_deferrals._fulfill();
          })(function() {
            return cb();
          });
        };
      })(this));
    };

    Key.prototype.export_to_protocol = function() {
      return {
        m: this.m.to_buffer(),
        s: this.s.to_buffer()
      };
    };

    return Key;

  })();

  exports.Cipher = Cipher = (function() {
    Cipher.V = C.protocol.version.V1;

    Cipher.prototype.V = Cipher.V;

    function Cipher(_arg) {
      this.key = _arg.key;
      this.block_cipher = new AES(this.key.s);
    }

    Cipher.generate_key = function(cb) {
      var key, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      key = new Key({});
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/messenger-core/src/cipher.iced",
            funcname: "Cipher.generate_key"
          });
          key.generate(__iced_deferrals.defer({
            lineno: 48
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          return cb(key);
        };
      })(this));
    };

    Cipher.checker = function(x) {
      return check_template([this.V, checkers.buffer(0), checkers.buffer(AES.ivSize, AES.ivSize), checkers.buffer(HMAC.outputSize, HMAC.outputSize)], x, "ciphertext");
    };

    Cipher.encode_to_db = function(x) {
      return encode({
        obj: x,
        encoding: 'msgpack64'
      }).toString('utf8');
    };

    Cipher.encode_to_stream = function(x) {
      return encode({
        obj: x,
        encoding: 'msgpack'
      });
    };

    Cipher.prototype.hmac = function(_arg, cb) {
      var b, buf, c, iv, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      c = _arg.c, iv = _arg.iv;
      buf = pack([this.V, c, iv]);
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/messenger-core/src/cipher.iced",
            funcname: "Cipher.hmac"
          });
          hmac.bulk_sign({
            key: _this.key.m,
            input: WordArray.from_buffer(buf)
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return b = arguments[0];
              };
            })(),
            lineno: 74
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          return cb(b.to_buffer());
        };
      })(this));
    };

    Cipher.prototype.encrypt = function(buf, cb) {
      var c, iv, m, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/messenger-core/src/cipher.iced",
            funcname: "Cipher.encrypt"
          });
          prng.generate(AES.ivSize, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return iv = arguments[0];
              };
            })(),
            lineno: 80
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/Users/max/src/keybase/messenger-core/src/cipher.iced",
              funcname: "Cipher.encrypt"
            });
            CTR.bulk_encrypt({
              block_cipher: _this.block_cipher,
              iv: iv,
              input: WordArray.from_buffer(buf)
            }, __iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return c = arguments[0];
                };
              })(),
              lineno: 81
            }));
            __iced_deferrals._fulfill();
          })(function() {
            c = c.to_buffer();
            iv = iv.to_buffer();
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/keybase/messenger-core/src/cipher.iced",
                funcname: "Cipher.encrypt"
              });
              _this.hmac({
                c: c,
                iv: iv
              }, __iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return m = arguments[0];
                  };
                })(),
                lineno: 84
              }));
              __iced_deferrals._fulfill();
            })(function() {
              return cb([_this.V, c, iv, m]);
            });
          });
        };
      })(this));
    };

    Cipher.prototype.decrypt = function(_arg, cb) {
      var args, c, err, iv, m, m2, ret, v, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      v = _arg[0], c = _arg[1], iv = _arg[2], m = _arg[3];
      err = ret = null;
      (function(_this) {
        return (function(__iced_k) {
          if (v !== _this.V) {
            return __iced_k(err = new Error("Can only handle V1"));
          } else {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/keybase/messenger-core/src/cipher.iced",
                funcname: "Cipher.decrypt"
              });
              _this.hmac({
                c: c,
                iv: iv
              }, __iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return m2 = arguments[0];
                  };
                })(),
                lineno: 93
              }));
              __iced_deferrals._fulfill();
            })(function() {
              (function(__iced_k) {
                if (!bufeq_secure(m, m2)) {
                  return __iced_k(err = new Error("HMAC mismatch"));
                } else {
                  args = {
                    block_cipher: _this.block_cipher,
                    iv: WordArray.from_buffer(iv),
                    input: WordArray.from_buffer(c)
                  };
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "/Users/max/src/keybase/messenger-core/src/cipher.iced",
                      funcname: "Cipher.decrypt"
                    });
                    CTR.bulk_encrypt(args, __iced_deferrals.defer({
                      assign_fn: (function() {
                        return function() {
                          return ret = arguments[0];
                        };
                      })(),
                      lineno: 102
                    }));
                    __iced_deferrals._fulfill();
                  })(function() {
                    return __iced_k(ret = ret.to_buffer());
                  });
                }
              })(__iced_k);
            });
          }
        });
      })(this)((function(_this) {
        return function() {
          return cb(err, ret);
        };
      })(this));
    };

    return Cipher;

  })();

}).call(this);
